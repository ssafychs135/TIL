# 파이썬의 깊은 복사와 얕은 복사

프로그래밍에서 데이터 복제 시 원본과의 연결성을 어떻게 다루는지에 따라 얕은 복사와 깊은 복사로 나뉩니다. 이를 이해하기 위해 먼저 단순 할당부터 알아봐야 합니다.

### 0. 단순 할당 (`b = a`) - 복사가 아닙니다!

단순 할당은 데이터를 복사하는 것이 아니라, 데이터가 저장된 메모리 주소에 **또 다른 이름표(변수)를 붙이는 것**과 같습니다. 원본과 완전히 동일한 객체를 가리키므로, 어느 한쪽을 변경하면 다른 쪽도 함께 변경됩니다.

```python
a = [1, 2, [3, 4]]
b = a  # b는 a와 완전히 동일한 객체를 가리킴

print(id(a) == id(b)) # True, 주소가 동일

b[0] = 99
print(a) # 출력: [99, 2, [3, 4]] -> a도 변경됨
```

---

### 1. 얕은 복사 (Shallow Copy)

얕은 복사는 **새로운 객체를 생성**하지만, 그 객체 안에 들어가는 내용물(내부 객체)은 **원본의 참조(메모리 주소)를 그대로 가져옵니다.**

-   **겉 껍데기만 복사**하고, 내용물은 원본과 공유한다고 생각하면 쉽습니다.
-   1차원 리스트처럼 내부 객체가 없는 경우에는 깊은 복사와 동일하게 동작하지만, 2차원 이상이나 내부에 다른 객체를 포함하면 **사이드 이펙트(side effect)**가 발생할 수 있습니다.
-   **사용법:** `copy.copy()`, `.copy()` 메서드, 슬라이싱 `[:]`

```python
import copy

a = [1, 2, [3, 4]]
b = copy.copy(a) # 얕은 복사

print(id(a) == id(b)) # False, 겉 껍데기는 다른 객체
print(id(a[2]) == id(b[2])) # True, 내부 객체는 주소 공유

# 내부 리스트를 변경하면 원본도 영향을 받음
b[2][0] = 99
print(a) # 출력: [1, 2, [99, 4]]

# 최상위 요소를 바꾸는 것은 영향을 주지 않음
b[0] = 100
print(a) # 출력: [1, 2, [99, 4]] (a[0]은 그대로 1)
```

---

### 2. 깊은 복사 (Deep Copy)

깊은 복사는 객체와 그 안에 포함된 **모든 내부 객체까지 재귀적으로 복사**하여, 원본과 완전히 독립적인 **새로운 객체**를 만듭니다.

-   **겉 껍데기와 내용물 모두**를 완벽하게 복제하여 새로운 것을 만듭니다.
-   원본 객체와의 연결을 완전히 끊고 싶을 때 사용합니다.
-   메모리를 더 사용하고 속도가 느릴 수 있지만, 가장 안전한 복사 방법입니다.
-   **사용법:** `copy.deepcopy()`

```python
import copy

a = [1, 2, [3, 4]]
b = copy.deepcopy(a) # 깊은 복사

print(id(a) == id(b)) # False, 겉 껍데기는 다른 객체
print(id(a[2]) == id(b[2])) # False, 내부 객체도 완전히 새로 복제됨

# b를 변경해도 a는 전혀 영향을 받지 않음
b[2][0] = 99
print(a) # 출력: [1, 2, [3, 4]]
```

---

### **핵심 요약**

| 구분 | 할당 (`=`) | 얕은 복사 (Shallow Copy) | 깊은 복사 (Deep Copy) |
| :--- | :--- | :--- | :--- |
| **개념** | 같은 객체에 다른 이름 부여 | 겉 껍데기만 복사 | 내용물까지 모두 복사 |
| **새 객체 생성** | ❌ (안 함) | ✅ (최상위 객체만) | ✅ (모든 객체) |
| **내부 객체** | 원본과 **완전히 공유** | 원본과 **참조 공유** | **완전히 독립** |
| **원본에 미치는 영향** | 항상 영향을 줌 | 내부 객체 수정 시 영향을 줌 | 전혀 영향을 주지 않음 |
| **사용법 (Python)** | `b = a` | `copy.copy(a)`, `a.copy()`, `a[:]` | `copy.deepcopy(a)` |

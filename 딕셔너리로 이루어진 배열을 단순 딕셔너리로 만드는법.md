# 파이썬: 딕셔너리 리스트를 단일 딕셔너리로 변환하기

`[{'key1': 'value1'}, {'key2': 'value2'}]` 형태의 리스트를 `{'key1': 'value1', 'key2': 'value2'}` 형태의 단일 딕셔너리로 변환하는 세 가지 주요 방법입니다.

### 1. `for` 루프 사용 (가장 직관적인 방법)

가장 기본적인 방법으로, 빈 딕셔너리를 만들고 리스트를 순회하며 각 딕셔너리의 내용을 추가합니다. 코드를 한 줄씩 따라가기 쉬워 이해하기 가장 좋습니다.

```python
# 원본 리스트
list_of_dicts = [{'a': 1}, {'b': 2}, {'c': 3}]

# 결과를 담을 빈 딕셔너리
single_dict = {}

# 리스트의 각 딕셔너리를 순회하며 update
for d in list_of_dicts:
    single_dict.update(d)

print(single_dict)
# 출력: {'a': 1, 'b': 2, 'c': 3}
```

### 2. 딕셔너리 컴프리헨션 (Dictionary Comprehension)

파이썬에 익숙한 사용자에게 추천되는 간결하고 효율적인 방법입니다. 한 줄로 코드를 작성할 수 있습니다.

```python
# 원본 리스트
a = [{'a': 1}, {'b': 2}, {'c': 3}]

# 딕셔너리 컴프리헨션을 사용하여 리스트를 단일 딕셔너리로 변환
# {k: v for d in a for k, v in d.items()}
# 이 한 줄의 코드는 아래와 같은 과정을 거칩니다.

# 1. 바깥쪽 루프: for d in a
#    - 리스트 a의 각 요소를 순서대로 변수 d에 할당합니다.
#    - 첫 번째 순회: d = {'a': 1}
#    - 두 번째 순회: d = {'b': 2}
#    - 세 번째 순회: d = {'c': 3}

# 2. 안쪽 루프: for k, v in d.items()
#    - 각 d (딕셔너리)에 대해 .items() 메서드를 호출하여 키-값 쌍을 가져옵니다.
#    - 가져온 키-값 쌍을 각각 변수 k와 v에 할당합니다.
#    - 첫 번째 바깥 순회 (d = {'a': 1})에서:
#        - k = 'a', v = 1
#    - 두 번째 바깥 순회 (d = {'b': 2})에서:
#        - k = 'b', v = 2
#    - 세 번째 바깥 순회 (d = {'c': 3})에서:
#        - k = 'c', v = 3

# 3. 표현식: {k: v ...}
#    - 안쪽 루프에서 얻은 각 k와 v를 사용하여 새로운 딕셔너리의 키-값 쌍을 만듭니다.
#    - 첫 번째 순회 결과: {'a': 1}
#    - 두 번째 순회 결과: {'a': 1, 'b': 2}
#    - 세 번째 순회 결과: {'a': 1, 'b': 2, 'c': 3}
#    - 이 과정이 모두 끝나면 최종적으로 하나의 딕셔너리가 생성됩니다.

b = {k: v for d in a for k, v in d.items()}

print(b)
# 최종 출력: {'a': 1, 'b': 2, 'c': 3}
```

### 3. `functools.reduce` 사용

함수형 프로그래밍 스타일을 선호할 경우 사용할 수 있는 방법입니다. `reduce` 함수와 딕셔너리 언패킹(`**`) 문법에 대한 이해가 필요합니다.

```python
# functools 모듈에서 reduce 함수를 가져옵니다.
from functools import reduce

# 원본 리스트
a = [{'a': 1}, {'b': 2}, {'c': 3, 'd': 4}]

# reduce 함수를 사용하여 리스트를 단일 딕셔너리로 변환
# reduce(lambda acc, cur: {**acc, **cur}, a, {})
# reduce 함수는 세 개의 인자를 받습니다: (함수, 순회 가능한 객체, 초기값)
# 여기서는 초기값을 생략했으므로, 리스트의 첫 번째 요소가 초기값으로 사용됩니다.

# 1. 람다 함수: lambda acc, cur: {**acc, **cur}
#    - 이 함수는 두 개의 인자(누적값 acc, 현재값 cur)를 받습니다.
#    - {**acc, **cur}는 딕셔너리 언패킹(unpacking) 문법입니다.
#      - **acc: 누적 딕셔너리의 모든 키-값 쌍을 풀어놓습니다.
#      - **cur: 현재 딕셔너리의 모든 키-값 쌍을 풀어놓습니다.
#    - 이 두 개를 합쳐 새로운 딕셔너리를 만들어 반환합니다.
#      예: acc = {'a': 1}, cur = {'b': 2}  ->  {**acc, **cur}는 {'a': 1, 'b': 2}가 됩니다.

# 2. reduce 함수의 작동 과정
#    - 초기값: reduce는 리스트 a의 첫 번째 요소인 {'a': 1}을 초기 누적값(acc)으로 사용합니다.
#    - 첫 번째 순회:
#        - acc = {'a': 1} (초기값)
#        - cur = {'b': 2} (리스트의 두 번째 요소)
#        - 람다 함수 실행: {**{'a': 1}, **{'b': 2}} -> {'a': 1, 'b': 2}
#        - 이 결과가 다음 순회의 acc가 됩니다.
#    - 두 번째 순회:
#        - acc = {'a': 1, 'b': 2}
#        - cur = {'c': 3, 'd': 4} (리스트의 세 번째 요소)
#        - 람다 함수 실행: {**{'a': 1, 'b': 2}, **{'c': 3, 'd': 4}} -> {'a': 1, 'b': 2, 'c': 3, 'd': 4}
#        - 이 결과가 다음 순회의 acc가 됩니다.
#    - 더 이상 순회할 요소가 없으므로, 최종 누적값인 {'a': 1, 'b': 2, 'c': 3, 'd': 4}를 반환합니다.

b = reduce(lambda acc, cur: {**acc, **cur}, a)

print(b)
# 최종 출력: {'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

### 요약

| 방법 | 장점 | 단점 | 추천 대상 |
| :--- | :--- | :--- | :--- |
| **for 루프** | **가장 이해하기 쉬움, 명시적** | 코드가 상대적으로 길어짐 | 파이썬 초급자, 가독성을 최우선으로 할 때 |
| **딕셔너리 컴프리헨션** | **간결하고 효율적 (Pythonic)** | 이중 `for` 구조가 처음엔 헷갈릴 수 있음 | 파이썬 중급자 이상, 간결한 코드를 선호할 때 |
| **`reduce`** | 매우 간결함, 함수형 스타일 | `reduce`와 `**` 문법이 익숙하지 않으면 가독성이 떨어짐 | 함수형 프로그래밍에 익숙한 사용자 |
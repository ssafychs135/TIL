# Collection

## Sequence형

| 시퀀스 형 |          |            |
| --------- | -------- | ---------- |
| type      | 변형가능 | 표현       |
| list      | 가변     | [ ]        |
| tuple     | 불변     | ( )        |
| string    | 불변     | ' ' or " " |
| range     |          | 숫자       |

-   sequence 형의 특징
    -   데이터의 순서가 중요
    -   인덱스를 통한 특정 위치의 데이터 잡근 가능
    -   슬라이싱을 통해 데이터 일부 추출 가능

### list

-   순서 유지
-   변경 가능
-   여러 자료형 보관 가능
-   ```py
      # 리스트의 생성
      my_list = [1, 'hello', True]

      # 인덱싱
      print(my_list=[0] )      # 출력: 1

      # 슬라이싱
      print(my_list = [1:0]) # 출력: ['hello', True]

      # 항목 추가
      my_list.append("world")
      print(my_list) # 출력 : [1,'hello', True, 'world']

      # 항목 삭제
      my_list.remove("hello")
      print(my_list) # 출력 : [1,True,'world']

      # list의 길이 출력
      print(len(my_list)) # 출력 : 3
    ```

### tuple

-   순서 유지
-   변경 불가능
-   다양한 타입 저장
-   ```py
      # 튜플을 생성
      my_tuple = (1, 'hello', True)

      # 인덱싱 (0부터 시작)
      print(my_tuple[0]) # 1
      # 슬라이싱
      print(my_tuple[1:0])    # 'hello',  True
      # 튜플 길이
      print(len(my_tuple)) # 3

      # 튜플은 변경 불가능, 아래의 코드는 에러가 발생한다
      my_tuple[0] = 2
    ```

### string

-   순서 유지
-   변경 불가능
-   ```py
      s1 = 'Hello'
      s2 = "Python"
      s3 = '''This is a
      multi-line string.'''
      # 인덱싱 및 슬라이싱
      print(s1[0])      # 출력: H
      print(s1[1:4])    # 출력: ell
      # 공백 제거
     s4 = "  Hello World  "
     print(s4.strip()) # 출력: "Hello World"
     # 문자열 분리
     s5 = "apple,banana,orange"
     print(s5.split(',')) # 출력: ['apple', 'banana', 'orange']

     # 문자열 치환
      print(s1.replace('l', 'w')) # 출력: Hewwo
    ```

### range

-   연속된 정수 시퀀스 생성
-   range는 객체를 반환하며, list나 tuple로 변환하여 사용 가능

## non sequence형

| 비 시퀀스형 |          |
| ----------- | -------- |
| type        | 변형가능 |
| dictonary   |          |
| set         |          |

-   non sequnece 의 특징
    -   순서가 중요하지 않음
    -   인덱스 사용 불가
    -   데이터 검색이나 중복 제거 등에 사용

### dictionary

-   변경 가능
-   key:value 형태로 구성
-   순서 없음
-   key는 중복될 수 없음, value는 가능
-   key 로는 변경불가능한 타입(문자열, 숫자, 튜플) 을 사용 가능
-   value로는 모든 타입 사용 가능

-   ```py
       # 딕셔너리 생성
      my_dict = {
           "name": "Alice",
           "age": 25,
           "city": "New York"
      }

       # 값 접근 (Key 사용)
       print(my_dict["name"])  # 출력: Alice

      # 값 변경
      my_dict["age"] = 26
      print(my_dict)  # 출력: {'name': 'Alice', 'age': 26,'city': 'New York'}

       # 새 항목 추가
      my_dict["email"] = "alice@example.com"
      print(my_dict)  # 출력: {'name': 'Alice', 'age': 26, 'city': 'New York', 'email': 'alice@example.com'}

      # 항목 삭제
      del my_dict["city"]
      print(my_dict)  # 출력: {'name': 'Alice', 'age': 26,'email': 'alice@example.com'}

     # Key 존재 여부 확인
     print("name" in my_dict)  # 출력: True
     print("country" in my_dict) # 출력: False

     '''
    * `get(key[, default])`: key에 해당하는 value를 반환합니다.
        key가 없으면 default 값을 반환합니다 (지정하지 않으면 None).
    * `keys()`: 딕셔너리의 모든 key를 담은 dict_keys 객체를
        반환합니다.
    * `values()`: 딕셔너리의 모든 value를 담은 dict_values 객체를
        반환합니다.
    * `items()`: 딕셔너리의 모든 (key, value) 쌍을 담은 dict_items
        객체를 반환합니다.
    * `pop(key[, default])`: key에 해당하는 항목을 제거하고 그
        value를 반환합니다.
    * `clear()`: 딕셔너리의 모든 항목을 제거합니다.
        '''

    ```

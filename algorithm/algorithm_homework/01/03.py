import sys

sys.stdin = open("input03.txt")

T = int(input())


'''

N개의 전등이 설치되어 있다. 각 전등은 1번부터 N번까지 번호가 붙어있고, i번 스위치를 조작하면 i번부터 N번까지의 전등의 켜짐/꺼짐 상태가 반대가 된다고 한다. 모든 전등의 현재 상태와 스위치 조작 후 상태가 주어지면 최소 몇 개의 스위치를 조작해야 하는지 알아내는 프로그램을 만드시오.

전등이 켜진 상태는 1, 꺼진 상태는 0으로 주어진다.
예를 들어 현재 상태 A가 0 0 0이고, 조작 후 상태 B가 0 1 0인 경우,

초기상태가  0 0 0 이므로,
2번 스위치를 조작해 0 1 1인 상태를 만들고,
3번 스위치를 조작해 0 1 0인 상태를 만들 수 있으므로, 최소 2번의 조작이 필요하다.

[입력]
첫 줄에 테스트케이스 개수 T, 다음 줄 부터 케이스 별로 스위치 개수 N, 다음 두 줄에 조작 전 스위치 상태 Ai와 조작 후 상태 Bi가 각각 N개씩 주어진다.
(1<=T<=10, 1<=N<=100)

[출력]
#과 케이스번호, 빈칸으로 구분된 답을 출력한다.


#1 2
#2 1
#3 3

'''

for tc in range(1, T+1):

    # N 전구 갯수
    # 조작 전, 조작 후
    N = int(input())
    bulbs = list(map(int, input().split())))
    bulbs_man = list( (map(int, input().split())))

    # i 번째 스위치를 조작하면 i 부터 N까지 전구 상태가 바뀐다
    # 전 후 배열의 교차가 몇번 이루어지는지 확인
    # 이전까진 같은 값이다 어떤 지점 a 에서 1,0로 갈린다면 그 위치에서 스위치가 눌린 것
    # 이렇게 갈린 횟수가 최소 조작량이다
    #  

    counts = 0
    count_flag = True

    for a in range(N):

        # 원본 배열을 순회하면서 나의 이전값과 다르며 변경 후 배열의 값과도 다른 지점에서 카운트
        if bulbs[a] != bulbs_man[a] and count_flag:
                counts +=1
                print(a)
                count_flag = not count_flag 

        
    

    print(f'#{tc} {counts}')